# Default method
- java 8 부터 등장
- 인터페이스 관리시, 추가로 메서드가 필요해지거나 기존 메서드에 인수를 추가하는 등의 이슈가 있을 경우 변경이 있을 때마다 인터페이스를 새로 만드는 것은 문제였다.
- 대표적으로 컬렉션 프레임워크에서 기능이 추가되어도 List와 Map 같은 핵심 인터페이스를 수정하지 못하는 상황이 발생.
- Collections 인터페이스에서 메서드가 추가되면 많은 라이브러리와 프레임워크에서 컴파일 에러가 나도 런타임 시점에는 NoSuchMethod 에러가 발생한다.
- 자바 8 이후로는 default Method를 활용해서 메서드 추가를 자유롭게 할 수 있다.

## 기존 인터페이스의 제약사항
- 상수를 선언할 수 있다. 
  - 값이 반드시 할당되어 있어야 하며 값을 변경할 수 없다.
  - 명시적으로 final 선언을 하지 않아도 final로 인식된다.
- 메서드는 반드시 <span style="color:red">추상(abstract) 메서드</span>여야 한다.
- 해당 인터페이스를 구현한 클래스는 인터페이스에서 정의한 메서드를 구현하지 않았다면 반드시 추상 클래스로 선되어야한다.
- 인터페이스에 선언된 상수와 메서드에 public을 선언하지 않더라도 public으로 인식한다.

## java 8 이후의 인터페이스 변화 (static, default method)
- 실제 코드가 완성되어 있는 static 메서드를 선언할 수 있다.
- 실제 코드가 완성되어 있는 default 메서드를 선언할 수 있다. (static 메서드와 default 메서드는 모두 public으로 인식하며 public은 생략 가능)
- 위 메서드들은 인터페이스 구현시 클래스에서 정의할 필요가 없다.
- 이전 버전에서는 인터페이스에 정의되어 있는 메서드를 반드시 클래스에 추가한 뒤 구현해야했으나 8부터는 default 메서드를 통해 인터페이스 자체에서 구현이 가능하므로 컴파일 에러가 발생하지 않는다.
- default 메서드의 예시
  - replaceAll, sort, spliterator 메서드가 List 인터페이스에 default 메서드로 선언되어 있다.(자바 11 기준)
## java 9 이후의 인터페이스 변화 (private method)
- 자바 9 부터는 private 메서드를 선언할 수 있는 점이 추가되었다.
- 인터페이스의 주 사용 목적이 클래스의 규격을 정의하는 것이기에 기존에는 public만 허용했었음.
- private method를 도입하므로써 외부에는 공개되지 않더라도 인터페이스 내부의 static 메서드와 default 메서드의 로직을 공통화하고 재사용하는데에 유용하다.
- private method는 규격정의만 해서는 안되고 실제 소스까지 구현해야만 하는 제약 조건이 있다.-> 결론적으로 static or default 메소드가 된다.


## 주의점
- 인터페이스 상에서 default 접근제한자는 메서드를 직접 구현하겠다고 컴파일러에게 알려주는 역할을 하지만 static 메서드와 private 메서드에는 별도 키워드 정의 없이 메서드의 명세를 선언하고 내용을 정의하면 된다.
- 인터페이스 내에 static과 private 메서드로 정의한 다음 코드를 작성하지 않으면 컴파일 에러가 발생한다.
- static과 private은 기존(자바 8이전)에 존재하지 않았던 형태라 상관이 없지만 default 메서드 같은 경우 기존 인터페이스의 추상 메서드와 일치하므로 컴파일러가 혼동을 일으킨다. 그래서 default라는 접근제한자를 통해 컴파일러에게 특별한 메서드 유형이라고 알리는 것.
- 인터페이스 상의 default 메서드는 오버라이드해서 재정의도 가능하다.

## 인터페이스와 추상클래스 
- 인터페이스의 큰 특징은 객체의 명세서를 정의하는 역할이다. 여기서 추상클래스와 인터페이스의 큰 차이점 두 가지?
  - 추상클래스는 멤버 변수를 가질 수 있지만, 인터페이스는 멤버변수를 가질 수 없다. 인터페이스는 static으로 정의된 변수를 내부적으로 선언하는 것만 가능하다.
  - 클래스를 구현할 때 오직 하나의 클래스만을 상속받을 수 있는 반면에 인터페이스는 여러 개를 상속받거나 구현할 수 있다.

- 여기서 인터페이스에 멤버 변수가 존재하지 않는다는 점은 인터페이스 자체를 객체화 할 수 없다는 것을 의미한다.
- 객체화 할 수 없는 인터페이스의 default메서드를 호출하고 싶은 경우에는 super연산자를 통해 불러온다.

## default 메서드와 다중상속 사이의 문제점
- 인터페이스에서 default 메서드가 생긴 후 제한적이지만 자바에서 다중 상속이 가능해졌다.
- 중요 원칙 세 가지
  - 클래스가 인터페이스에 대해 우선순위를 가진다. 동일한 메서드가 인터페이스와 클래스에 둘 다 있다면 클래스가 먼저 호출된다.
  - 만약, 상속 관계에 있을 경우 하위 클래스/인터페이스가 상위보다 우선적으로 호출된다.
  - 메서드 호출 시 어떤 메서드를 호출해야할지 모호할 경우(다이아몬드 상속?)에는 컴파일 에러가 발생할 수 있으며, 반드시 호출하고자 하는 클래스 혹은 인터페이스를 명확하게 지정해야한다.

## 결론
- 자바 버전이 올라감에 따라 인터페이스에 정의할 수 있는 항목이 늘어났다. 하지만, 인터페이스의 본연의 기능은 클래스에 대한 명세서 역할과 일관된 접근 경로를 제공하고 클래스의 캡슐화를 돕는 역할로 한정하는 것이 안정적인 코딩에 도움이 된다는 것을 명심하자.
- default 메서드를 사용할 경우 영향을 최소화 하는 수준에서 사용하자.

#### 출처
- Practical 모던 자바 - 장윤기