# CQRS (Command Query Responsibility Segregation)
- 애플리케이션을 구현함에 있어 명령과 조회의 책임을 분리한다.

## 명령과 조회를 분리하는 이유
- 전통적인 애플리케이션에서 데이터를 DB에 저장하는 과정에서 이 데이터를 특정 모델(Model)로써 다뤄지게 된다.(class파일? dto 느낌)
- 애플리케이션이 커지면서 이 모델은 거대하게 확장되거나 변질되게 된다. 예를 들어, 상품 모델이 있으면, 상품대분류 모델, 상품코드관련 모델들이 추가로 붙는 구조.
- 애플리케이션이 복잡해지면, 데이터를 저장, 갱신, 삭제(CUD)하는 모델과 조회(R) 전용 모델을 분리하여 관리하게 된다. 이부분이 CQRS가 등장하게 된 배경이다.

## CQRS 패턴 특징
- CQRS 패턴은 다양한 방법론과 기술로써 구현할 수 있다.
- CQRS 패턴은 이벤트 소싱 패턴을 함께 사용하여 구현한다.(복잡성이 증가할 수 있다.)
- 명령처리, 업데이트 이벤트를 게시하는데에 메시징을 사용한다. APP 부분에서 애플리케이션은 메시지 오류 또는 중복 메시지를 처리해야 한다.
- 읽기 및 쓰기 데이터베이스를 구분하는 경우 읽기 데이터는 기한이 경과되는 경우도 있다.
- 읽기 모델의 저장소는 쓰기 모델 저장소의 변경 내용을 반영하도록 업데이트 되어야 한다.
- 사용자가 오래된 읽기 데이터를 기반으로 요청을 발행한 경우를 감지하기 어려울 수도 있다.

## CQRS 패턴을 사용하는 경우
- 많은 사용자가 동일한 데이터에 병렬 엑세스하는 경우
- 개발자 중 한팀은 쓰기 모델, 한팀은 읽기 모델 이런식으로 업무 도메인을 나눌 수 있는 경우
- 시스템의 변경이 잦은 경우.(여러 버전의 모델을 가짐, 비즈니스 규칙이 자주 변함 등등)
- 가장 가치있는 시스템의 제한된 구역에만 CQRS 적용을 한다. DDD 용어에서 말하는 Bounded Context에만 사용한다.
